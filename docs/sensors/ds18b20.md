# DS18B20 — 1-Wire Temperature Sensor
**Driver:** `WyDS18B20.h`

---

## What it does
Waterproof digital temperature sensor. One wire carries power, ground (optional), and data. Multiple sensors can share a single GPIO pin. Factory-calibrated, ±0.5°C accurate, -55°C to +125°C.

## Why it's great
- **Waterproof** — stainless steel probe version lives in liquids, soil, pipes, tanks
- **Multiple sensors, one pin** — up to 127 DS18B20s on a single GPIO
- **No calibration needed** — factory-calibrated and consistent unit-to-unit
- **Long cable runs** — works over 100m of cable (with appropriate pullup)
- **CRC on every read** — corrupted reads are detected, never silently wrong

## Wiring
**Standard 3-wire (recommended):**
| DS18B20 | ESP32 |
|---------|-------|
| GND (black) | GND |
| VDD (red) | 3.3V |
| DQ (yellow/white) | GPIO + **4.7kΩ to 3.3V** |

**The 4.7kΩ pull-up resistor is mandatory.** Without it the bus stays LOW and nothing works.

**Long runs (>10m):** use 2.2kΩ pullup — stronger drive for line capacitance.  
**Many sensors (>10):** add a second 4.7kΩ in parallel (effective 2.35kΩ).  
**Parasitic 2-wire:** leave VDD unconnected, tie only GND and DQ. Works but limits range and sensor count. Avoid on new designs.

## Basic usage
```cpp
auto* ds = sensors.addGPIO<WyDS18B20>("water", GPIO34);
sensors.begin();

WySensorData d = sensors.read("water");
if (d.ok) Serial.printf("%.2f°C\n", d.temperature);
else       Serial.println(d.error);
```

## Multiple sensors on one pin
```cpp
sensors.addGPIO<WyDS18B20>("water",   4);     // index 0 — first found
sensors.addGPIO<WyDS18B20>("ambient", 4, 1);  // index 1 — second found
sensors.addGPIO<WyDS18B20>("inlet",   4, 2);  // index 2 — third found
```

On `begin()`, the driver:
- Index 0 on single-sensor bus: uses `READ ROM` (fast, skips search)
- Index 0 with multiple sensors: falls back to `SKIP ROM` broadcast
- Index 1+: runs full 1-Wire ROM search, stores the specific 64-bit ROM address

After `begin()`, each named sensor talks directly to its own chip by ROM address — reads are independent and addressed correctly.

## Identify sensors by ROM address
```cpp
ds->printROM();
// [DS18B20] ROM: 28:FF:A3:B2:41:17:04:C5
```

Each DS18B20 has a unique 64-bit factory-programmed address. Use `printROM()` to identify which physical probe corresponds to which name — attach them one at a time to a single-device bus, read the ROM, label the probe.

## Resolution and conversion time
```cpp
ds->setResolution(9);   // 9-bit:  94ms,   ±0.5°C
ds->setResolution(10);  // 10-bit: 188ms,  ±0.25°C
ds->setResolution(11);  // 11-bit: 375ms,  ±0.125°C
ds->setResolution(12);  // 12-bit: 750ms,  ±0.0625°C  ← default
```

Call `setResolution()` before `begin()` or after (writes to sensor scratchpad). For fast-update dashboards use 9-bit. For fish tank / aquarium precision use 12-bit.

## Non-blocking conversion
The default `read()` blocks for up to 750ms. Use the non-blocking API to do other work during conversion:

```cpp
ds->startConversion();            // returns immediately
// ... do other stuff for 750ms
float t = ds->readTemperature();  // read scratchpad
if (!isnan(t)) Serial.printf("%.4f°C\n", t);

// Or poll:
ds->startConversion();
while (!ds->conversionDone()) yield();  // or delay(1)
float t = ds->readTemperature();
```

## Simultaneous conversion (multiple sensors, fastest approach)
```cpp
// Start all sensors at once (broadcast SKIP ROM):
ds0->startConversionAll();     // or any instance
delay(ds0->conversionMs());    // wait for all to complete

// Then read each individually:
float t0 = ds0->readTemperature();
float t1 = ds1->readTemperature();
float t2 = ds2->readTemperature();
```

This is faster than reading sensors sequentially (each read would trigger a new 750ms conversion). Start all, wait once, read all.

## Alarm thresholds
```cpp
// Alert if temp goes above 30°C or below 5°C:
ds->setAlarm(30, 5);

// Alarms are stored in sensor EEPROM — persist after power-off
// Use alarm search (0xEC) to find triggered sensors (advanced use)
```

## WySensorData fields
| Field | Content |
|-------|---------|
| `d.temperature` | Temperature in °C |
| `d.ok` | true if read succeeded and CRC passed |
| `d.error` | "no presence pulse" / "CRC fail" / "conversion timeout" |

## ⚠️ Timing is critical — interrupt interference
1-Wire bit-banging uses µs-level timing with `noInterrupts()` guards. WiFi interrupt bursts can still corrupt reads (interrupt re-enables between bits). If seeing frequent CRC failures:

1. Check the 4.7kΩ pullup is present
2. Reduce resolution (9-bit = 8× faster, less exposure to interference)
3. Move DS18B20 reads to non-WiFi-transmit windows
4. Try a stronger pullup (2.2kΩ)
5. Reduce cable length

CRC failures are always returned as errors — the driver never gives you a silently wrong temperature.

## Fish tank / aquarium
One GPIO, three probes:
```cpp
sensors.addGPIO<WyDS18B20>("tank",   4);    // submerged
sensors.addGPIO<WyDS18B20>("ambient", 4, 1); // air above tank
sensors.addGPIO<WyDS18B20>("sump",   4, 2); // filter output
```

Pairs naturally with `WyPH` for temperature-compensated pH, and `WyTurbidity` for water quality monitoring. The DS18B20 temp reading feeds directly into pH calibration slope correction.

## Parasitic power mode
Two-wire connection (GND + DQ, no VDD). The sensor draws power from the data line during the high period. Limitations:
- Shorter cable runs (parasitic current limits line voltage)
- Fewer sensors per bus (more current draw)
- Some operations (COPY SCRATCHPAD) need external VDD applied momentarily

If you're doing parasitic power, use a strong pull-up transistor (not just a resistor) controlled by a second GPIO during conversion. Generally not worth the complexity — use 3-wire if at all possible.
