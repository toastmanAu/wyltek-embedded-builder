# MLX90640 — 32×24 IR Thermal Camera
**Driver:** `WyMLX90640.h`

---

## What it is
A 32×24 array of thermopiles on a chip. Each of the 768 pixels independently measures infrared radiation and reports a temperature in °C. Output: a heat map of whatever it's pointed at.

- Resolution: 0.1°C sensitivity, ±1.5°C accuracy (typical)
- Range: -40°C to +300°C object temperature
- Field of view: **55°×35°** (BAA) or **110°×75°** (BAB — ultra-wide)
- Frame rates: 0.5 to 32 Hz
- I2C address: 0x33 (default), pin-selectable 0x30–0x37

## Wiring
| MLX90640 | ESP32 |
|----------|-------|
| SDA | SDA (2.2kΩ pull-up to 3.3V) |
| SCL | SCL (2.2kΩ pull-up to 3.3V) |
| VDD | 3.3V + decoupling caps (see below) |
| GND | GND |
| AD0/AD1/AD2 | GND (address = 0x33) |

## ⚠️ Decoupling caps — not optional
The MLX90640 draws current spikes during I2C reads that can glitch the VDD rail and corrupt the EEPROM read. Place **100µF electrolytic + 100nF ceramic** directly at the sensor's VDD pin. Without this, calibration extraction produces garbage and `begin()` fails.

## ⚠️ Pull-up strength
Standard 4.7kΩ pull-ups are too weak above 400kHz. Use **2.2kΩ** for reliable fast I2C. If you see read failures, try shorter wires before anything else.

## Basic usage
```cpp
auto* cam = sensors.addI2C<WyMLX90640>("thermal", SDA_PIN, SCL_PIN, 0x33);
cam->setFrameRate(MLX_FPS_4);      // 4Hz refresh
cam->setEmissivity(0.95f);         // most surfaces: 0.92–0.97
sensors.begin();

void loop() {
    WySensorData d = sensors.read("thermal");
    if (d.ok) {
        Serial.printf("Hotspot: %.1f°C at pixel %d\n", d.raw, d.rawInt);
        Serial.printf("Centre: %.1f°C  Ambient: %.1f°C\n",
            cam->centerTemp(), d.temperature);
    }
}
```

## Frame rates
| Code | Rate | Notes |
|------|------|-------|
| `MLX_FPS_0_5` | 0.5 Hz | Lowest noise, lowest power |
| `MLX_FPS_2` | 2 Hz | Default — good balance |
| `MLX_FPS_4` | 4 Hz | Good real-time feel |
| `MLX_FPS_8` | 8 Hz | Smooth — driver auto-bumps I2C to 1MHz |
| `MLX_FPS_32` | 32 Hz | Requires 1MHz I2C, fast display loop |

Higher frame rates = more noise in the image. For static scenes (thermal inspection, monitoring) use 2Hz. For tracking movement, 8Hz.

## Emissivity
Different surfaces emit IR differently. Setting emissivity correctly matters:

| Surface | Emissivity |
|---------|------------|
| Human skin | 0.98 |
| Most plastics | 0.95 |
| Painted metal | 0.92–0.96 |
| PCB / fibreglass | 0.91 |
| Black anodised aluminium | 0.88 |
| Bare aluminium | 0.05–0.15 ← terrible |
| Glass | 0.90 |
| Water | 0.98 |

Shiny metals are nearly invisible to IR sensors. Paint them matt black if you need to measure temperature accurately.

## False colour display — ironbow palette
```cpp
float* px = cam->pixels();    // 768 floats, row-major [row*32 + col]
float lo = cam->minTemp();
float hi = cam->maxTemp();

for (int row = 0; row < 24; row++) {
    for (int col = 0; col < 32; col++) {
        float t = (px[row*32+col] - lo) / (hi - lo);  // 0.0–1.0
        uint16_t colour = WyMLX90640::ironbow(t);      // RGB565
        tft.fillRect(col * scale, row * scale, scale, scale, colour);
    }
}
```

Or use the one-liner (works with TFT_eSPI or Arduino_GFX):
```cpp
cam->render(&tft, 0, 0, 10);   // scale=10 → 320×240 (fills CYD screen)
cam->render(&tft, 0, 0, 6);    // scale=6  → 192×144 (centred on CYD)
```

**Ironbow** goes: black → indigo → blue → magenta → red → orange → yellow → white. Classic thermal camera look. Also available: `WyMLX90640::rainbow()` for blue→cyan→green→yellow→red.

## Memory
The driver uses ~5KB RAM:
- Calibration struct: ~300 bytes
- Raw frame buffer: 1664 bytes
- Pixel float array: 3072 bytes

Fine on any ESP32. Would be tight on AVR (2KB). If you have PSRAM, allocate `_pixels` there using `ps_malloc()` — modify the driver for that.

## How the calibration works
The sensor ships with 832 words of calibration data in onboard EEPROM. `begin()` reads all of it and extracts ~50 parameters: per-pixel gain, offset, sensitivity (alpha), temperature coefficients, supply voltage correction, ambient temperature coefficients, and more.

Every frame requires applying all these corrections to 768 raw ADC values. It's ~200 lines of floating-point math per frame from the Melexis AN#0101 application note. The driver implements it fully.

## WySensorData fields
| Field | Content |
|-------|---------|
| `d.temperature` | Ambient sensor temperature (Ta, °C) |
| `d.raw` | Hottest pixel temperature (°C) |
| `d.rawInt` | Index of hottest pixel (0–767) — row = idx/32, col = idx%32 |
| `d.ok` | true when frame valid |

## BAA vs BAB — which module to buy
- **BAA (55°×35°)**: better for medium-distance monitoring — people detection from 2–5m, PCB inspection, equipment monitoring
- **BAB (110°×75°)**: better for close range — body temperature, small object inspection, wide-area room coverage

Most AliExpress listings don't specify BAA/BAB. Check the part number on the sensor chip itself.

## Gotchas
**I2C chunking** — The ESP32 Wire library limits a single `requestFrom()` to 32 bytes. The driver reads 16 words (32 bytes) per transaction and loops. If your Wire implementation has different limits, adjust `CHUNK` in `_readWords()`.

**Frame timing** — The driver polls the status register for the data-ready flag rather than using a fixed delay. This adapts to the configured frame rate automatically.

**Scene dynamic range** — The ironbow palette maps min→max of the current frame. In a scene where everything is at similar temperatures (e.g. 35–37°C), tiny differences get stretched across the full colour range. This makes it look dramatic but the numbers are close. Always check `minTemp()`/`maxTemp()` for context.

**32Hz requires fast loop** — At 32Hz, you have 31ms to read + render + do anything else. On a CYD at scale=6 (192×144 = 27,648 fillRect calls), rendering alone can take >100ms. For high frame rates: use DMA-based display drivers or write raw scanlines.

## Cool projects
- **People counter**: count hot blobs in frame, track movement direction
- **PCB inspection**: spot hot components under load without a $2000 thermal camera
- **Contactless temperature**: aim at forehead from 20cm, read centre pixel
- **Fire detection**: threshold pixel max > 60°C → alert
- **HVAC visualisation**: see hot/cold air distribution in a room
- **Animal detection**: in a barn or pen, hot blobs = animals
