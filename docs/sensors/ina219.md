# INA219 — Current / Voltage / Power Monitor
**Driver:** `WyINA219.h`

---

## What it does
Measures current, voltage, and power simultaneously. Sits in series with the thing you're powering — reads the tiny voltage drop across a shunt resistor and converts it to amps. Also reads the bus voltage directly. Multiply the two → watts. Integrate over time → watt-hours.

- Bus voltage: 0–26V, 4mV resolution
- Current: depends on shunt resistor (see below)
- Power: bus voltage × current, computed on-chip
- I2C, up to 16 units on one bus (0x40–0x4F)
- 3.3V or 5V supply for the chip itself; measures circuits up to 26V

## The shunt resistor — most important decision

Current is measured indirectly. A small resistor sits in series with the load. The INA219 measures the tiny voltage drop across it (Ohm's law: V = I × R → I = V/R).

**Most breakout boards come with 0.1Ω — good for 0–3.2A.**

| Shunt | Max current | Resolution | Use case |
|-------|-------------|------------|----------|
| 0.01Ω | 32A | ~1mA | Motor control, solar, battery charging |
| 0.1Ω | 3.2A | ~0.1mA | Default — general purpose |
| 0.5Ω | 640mA | ~0.02mA | USB power monitoring |
| 1.0Ω | 320mA | ~0.01mA | Micro-power / sleep current |

For micro-power measurement (ESP32 deep sleep, IoT devices on batteries), pair with a 1Ω shunt and `INA219_GAIN_1` — resolution drops to ~10µA.

## Wiring — the shunt goes IN SERIES

```
Power supply (+) → INA219 V+ → [shunt 0.1Ω] → INA219 V- → Load (+)
Load (-) → GND
INA219 VCC → 3.3V
INA219 GND → GND (same ground as measured circuit)
INA219 SDA → ESP32 SDA
INA219 SCL → ESP32 SCL
```

The shunt is already on the board — the V+ and V- screw terminals straddle it. Just wire power through them.

### ⚠️ Common ground is mandatory
The INA219's GND must be at the same potential as the negative return of the measured circuit. For 5V or 12V systems, only the shunt (V+/V-) touches the high-voltage side. The chip side stays at 3.3V.

### ⚠️ Bus voltage limit: 26V
The V+ pin (high side of shunt) is limited to 26V absolute max. For 24V systems you're at the edge — use with caution. For 48V systems, use INA228 or INA260 instead.

## Basic usage
```cpp
auto* pwr = sensors.addI2C<WyINA219>("power", SDA_PIN, SCL_PIN, 0x40);
sensors.begin();

WySensorData d = sensors.read("power");
if (d.ok) {
    Serial.printf("%.3fV  %.3fA  %.3fW\n",
        d.voltage, d.current, d.weight);
}
```

## WySensorData fields
| Field | Content |
|-------|---------|
| `d.voltage` | Bus voltage (V) |
| `d.current` | Current (A) — negative = reverse flow |
| `d.weight` | Power (W) |
| `d.raw` | Shunt voltage (mV) — useful for debugging |
| `d.ok` | true when reading valid |
| `d.error` | "overflow" if current exceeds shunt range |

## Gain settings — matching to your current range

```cpp
pwr->setGain(INA219_GAIN_1);   // ±40mV  — max 400mA with 0.1Ω, best resolution
pwr->setGain(INA219_GAIN_2);   // ±80mV  — max 800mA
pwr->setGain(INA219_GAIN_4);   // ±160mV — max 1.6A
pwr->setGain(INA219_GAIN_8);   // ±320mV — max 3.2A (default)
```

Use the smallest gain that covers your max current — you get better resolution. If you're measuring a 500mA load, `GAIN_2` gives you 4× better resolution than `GAIN_8`.

## Setting max current for best calibration
```cpp
pwr->setMaxCurrent(0.5f);   // 500mA max → tunes LSB for best resolution
pwr->setGain(INA219_GAIN_2);
```

The calibration register controls the current LSB (amps per count). Smaller LSB = finer resolution but lower max. Telling the driver your max current sets this optimally.

## ADC averaging — reducing noise
```cpp
pwr->setADCMode(INA219_ADC_12BIT_16AVG);   // 16-sample average, ~8.5ms/reading
pwr->setADCMode(INA219_ADC_12BIT_128AVG);  // 128-sample average, ~68ms — smoothest
```

For monitoring slow-changing things (solar output, battery state), 128-sample averaging is worth the 68ms delay. For fast-changing loads (motors, switching), use single-sample or 4-sample.

## I2C address table — up to 16 on one bus
| A1 | A0 | Address |
|----|----|---------| 
| GND | GND | 0x40 (default) |
| GND | VCC | 0x41 |
| GND | SDA | 0x42 |
| GND | SCL | 0x43 |
| VCC | GND | 0x44 |
| VCC | VCC | 0x45 |

Most breakout boards only expose A0/A1 solder bridges for GND/VCC options (0x40–0x45). Full 0x40–0x4F range requires connecting to SDA/SCL lines.

## Multiple monitors — solar + battery + load example
```cpp
auto* solar  = sensors.addI2C<WyINA219>("solar",   SDA, SCL, 0x40);
auto* battery= sensors.addI2C<WyINA219>("battery", SDA, SCL, 0x41);
auto* load   = sensors.addI2C<WyINA219>("load",    SDA, SCL, 0x44);
sensors.begin();

// Energy balance check:
// solar input - load draw should equal battery charge rate
float solarW    = sensors.read("solar").weight;
float loadW     = sensors.read("load").weight;
float batteryW  = sensors.read("battery").weight;   // negative = charging
```

## Energy accumulation (Wh)
```cpp
// Call regularly (e.g. every second) to accumulate watt-hours
float totalWh = pwr->energyWh();
Serial.printf("Energy used: %.3f Wh\n", totalWh);

// Reset at midnight or start of measurement period:
pwr->resetEnergy();
```

## One-shot / triggered mode — for low-power designs
```cpp
pwr->setMode(INA219_MODE_BOTH_TRIG);   // only convert when read() is called
// Between reads, chip draws ~6µA standby vs ~1mA continuous
```

Useful in deep-sleep designs where you only take readings periodically.

## Detecting reverse current
`d.current` is signed. Negative = current flowing backwards through the shunt (e.g. battery charging vs discharging, or a motor regenerating). Useful for bidirectional monitoring.

## Gotchas
**Calibration register must be set before reading current/power registers.** The driver sets it in `begin()`. If you change gain with `setGain()` after `begin()`, call `begin()` again to recalculate and re-apply calibration.

**Current register reads zero?** The calibration register may have been cleared by a power glitch. Check that `begin()` ran successfully and the calibration value was written. The Ohm's law fallback in `read()` catches this: if the hardware current register returns 0, it computes current from the shunt voltage directly.

**Shunt voltage reads correct but current is wrong?** Almost always a wrong shunt value passed to the constructor, or shunt register cleared. Verify with `d.raw` (shunt mV) — `current = d.raw / 1000.0 / shuntOhm`.
