# Sharp GP2Y0A02 — Infrared Distance Sensor
**Driver:** `WyGP2Y0A02.h`

---

## What it does
Measures distance using infrared light. Outputs an analog voltage that corresponds to the distance to the nearest object in front of the sensor. No computation on your end — just read the voltage and convert to centimetres using a curve.

## Variants and ranges

This driver handles the whole Sharp GP2Y IR distance family:

| Model | Range | Build flag |
|-------|-------|-----------|
| GP2Y0A02YK0F | 20–150cm | `-DWY_GP2Y_MODEL=2` (default) |
| GP2Y0A21YK0F | 10–80cm | `-DWY_GP2Y_MODEL=21` |
| GP2Y0A710K0F | 100–500cm | `-DWY_GP2Y_MODEL=710` |

Aliases `WyGP2Y0A21` and `WyGP2Y0A710` map to the same class.

## Wiring

| GP2Y0A02 | ESP32 |
|---------|-------|
| VCC (red) | 5V (required — 4.5–5.5V) |
| GND (black) | GND |
| Vo (white/yellow) | ESP32 ADC pin + 100nF cap to GND |

**The sensor must run on 5V.** The output voltage is proportional to the supply, so 3.3V supply changes the curve. Run on 5V (from VIN/USB).

**Output is safe for 3.3V ADC.** The maximum output voltage from the GP2Y0A02 is about 2.8V (at 20cm, the closest valid range), well within the ESP32's 3.3V ADC range.

**Add a 100nF decoupling capacitor** between Vo and GND right at the sensor's output. The internal LED pulses rapidly and creates switching noise on the output line.

## Specs

| Parameter | GP2Y0A02 | GP2Y0A21 |
|-----------|---------|---------|
| Range | 20–150cm | 10–80cm |
| Output | Analog voltage | Analog voltage |
| Supply | 4.5–5.5V | 4.5–5.5V |
| Response time | 38.3ms ±9.6ms | 38.3ms ±9.6ms |
| Supply current | ~33mA | ~33mA |

## Voltage curve (approximate)

The output is **non-linear** and **inverted** — closer objects give higher voltage:

| Distance | Approx voltage |
|---------|---------------|
| 20cm | ~2.8V |
| 40cm | ~1.4V |
| 80cm | ~0.7V |
| 120cm | ~0.5V |
| 150cm | ~0.4V |

The driver applies a power-law curve: `distance_cm = A × voltage ^ B` (fitted from the datasheet characteristic).

## Code Example

```cpp
#include <WySensors.h>

WySensors sensors;

void setup() {
    sensors.addGPIO<WyGP2Y0A02>("ir_dist", 34);  // ADC pin
    sensors.begin();
}

void loop() {
    WySensorData d = sensors.read("ir_dist");
    if (d.ok) {
        Serial.printf("Distance: %.1f cm  (%.0f mm)\n",
            d.raw, d.distance);
    } else if (d.error) {
        Serial.printf("Error: %s  voltage: %.0f mV\n",
            d.error, d.voltage);
    }
    delay(100);
}
```

## WySensorData fields

| Field | Content |
|-------|---------|
| `distance` | Distance in mm |
| `raw` | Distance in cm |
| `voltage` | Raw ADC voltage in mV |
| `ok` | `true` if in valid range |
| `error` | `"too close"`, `"out of range"`, `"no signal — check wiring"` |

## Changing models

```cpp
// Using 10-80cm version:
// Build with: -DWY_GP2Y_MODEL=21
sensors.addGPIO<WyGP2Y0A21>("short_range", 34);

// Using 100-500cm version:
// Build with: -DWY_GP2Y_MODEL=710
sensors.addGPIO<WyGP2Y0A710>("long_range", 34);
```

## Custom curve fitting

If your sensor's curve doesn't match the defaults (manufacturing variation), you can supply your own constants:

```cpp
auto* sensor = sensors.addGPIO<WyGP2Y0A02>("dist", 34);
sensor->setCurve(61.0f, -1.09f);  // A and B from your own fit
```

## Gotchas

**The voltage drops below 20cm — readings become invalid.** At very close range (<20cm) the voltage drops again, creating a second mapping where the distance looks further than it is. The driver returns `"too close"` for readings below the minimum range.

**Reading faster than 38ms gets repeated samples.** The internal LED fires at ~25Hz. The driver takes 5 averaged samples with 2ms between them (~10ms total). Reading faster than 38ms just re-reads the last LED cycle's conversion.

**ESP32 ADC is non-linear.** The ESP32's ADC has a known non-linearity around 1V. For precise readings, use `analogReadMilliVolts()` (if available in your framework) or apply the ESP32's ADC calibration. The driver uses a simple conversion (ADC count → mV) which may be off by ±5% in the 0.5–1.5V range.

**5V sensor, 3.3V ESP32 supply.** Use the USB 5V (VIN pin) not the 3.3V regulator output. Draw current from the 5V line to the sensor, not through the 3.3V regulator.

**IR interference in sunlight.** Bright sunlight contains a lot of IR and can saturate the sensor's receiver. The sensor works best indoors or in shaded conditions.

**Averaging reduces noise.** The default is 5 samples (`WY_GP2Y_SAMPLES`). Increase for smoother readings in noisy environments: `-DWY_GP2Y_SAMPLES=10`
