# MICS-5524 — MEMS Reducing Gas Sensor
**Driver:** `WyMICS5524.h`

---

## What it detects
Reducing gases — gases that donate electrons to the metal oxide surface and lower its resistance:

| Gas | Range | Use case |
|-----|-------|----------|
| CO (carbon monoxide) | 10–500 ppm | Safety, combustion monitoring |
| Ethanol | 10–500 ppm | Alcohol detection, fermentation |
| Hydrogen | 1–1000 ppm | Hydrogen safety, fuel cells |
| Ammonia | 1–500 ppm | Air quality, agriculture |
| Methane (partial) | >1000 ppm | Less sensitive — use MQ-4 for CH4 |

**It cannot tell these gases apart.** It measures total reducing gas load. If you need gas identification, pair with an ENS160 (which has better algorithm but similar limitation) or add dedicated sensors per target gas.

## MICS-5524 vs MQ series

| | MICS-5524 | MQ-2 / MQ-7 etc |
|--|-----------|-----------------|
| Form factor | MEMS chip (tiny) | Ceramic bead (large) |
| Power draw | 35–70 mW | 150–950 mW |
| Warm-up | 30s (normal), 3min (cold) | 1–2 minutes |
| Response time | <30 seconds | 60–120 seconds |
| Battery suitability | Good | Poor |
| Supply | 1.8–5V | 5V |

Better choice for portable, battery-powered, or space-constrained designs.

## Wiring
Most breakout boards: VCC, GND, AOUT, (optional DOUT)

**3.3V supply (simplest):**
```
VCC  → 3.3V
GND  → GND
AOUT → ESP32 ADC1 pin (GPIO32–39)
setSupplyVoltage(3.3f)
```

**5V supply (common on Arduino breakouts):**
```
VCC  → 5V
GND  → GND
AOUT → 100kΩ → ESP32 ADC1 pin
             → 100kΩ → GND   (voltage divider)
setSupplyVoltage(5.0f)
setDividerRatio(0.5f)
```

## Basic usage
```cpp
auto* gas = sensors.addGPIO<WyMICS5524>("gas", GPIO34);
gas->setSupplyVoltage(3.3f);
gas->setLoadResistance(10.0f);  // kΩ — check your board schematic
gas->setR0(10.0f);              // kΩ — CALIBRATE THIS (see below)
sensors.begin();

void loop() {
    WySensorData d = sensors.read("gas");
    if (!d.ok) {
        Serial.printf("Warming up... %ds remaining\n", (int)d.raw);
    } else {
        Serial.printf("CO: %.0f ppm  Ethanol: %.0f ppm  Rs: %.2f kΩ\n",
            d.co2, d.raw, d.voltage);
    }
    delay(1000);
}
```

## WySensorData fields
| Field | Content |
|-------|---------|
| `d.co2` | Estimated CO (ppm) |
| `d.raw` | Estimated Ethanol (ppm) |
| `d.voltage` | Sensor resistance Rs (kΩ) |
| `d.rawInt` | Rs/R0 ratio × 100 |
| `d.ok` | false during warm-up |
| `d.error` | "warming up" during warm-up period |

For H₂ and NH₃: `gas->ppmH2()`, `gas->ppmNH3()` — direct calls.

## ⚠️ R0 calibration — you must do this

R0 is the sensor resistance in clean fresh air. It's the reference point all ppm calculations are based on. Without calibrating it for your specific unit, the ppm numbers are meaningless.

**Calibration procedure:**
1. Take the sensor outside or to a very well-ventilated space (fresh air, no nearby combustion, no traffic fumes)
2. Power it on and wait **3 minutes minimum** (cold start)
3. Call `calibrateR0()`:

```cpp
// One-time calibration sketch:
gas->setWarmupSeconds(180);   // 3-minute cold-start warm-up
sensors.begin();

// Wait for warm-up
while (!gas->isWarmedUp()) {
    Serial.printf("Warming up: %ds\n", (int)sensors.read("gas").raw);
    delay(5000);
}

float r0 = gas->calibrateR0();
Serial.printf("Your R0 = %.3f kΩ — store this in NVS\n", r0);
```

4. Store R0 in NVS (non-volatile storage) and restore it on every boot:

```cpp
// On boot:
float r0 = nvs.getFloat("mics_r0", 10.0f);  // 10.0 fallback
gas->setR0(r0);
```

**Typical R0 values:** 10–50 kΩ in fresh air (varies by unit, age, environment).

## Warm-up time

| Situation | Warm-up needed |
|-----------|---------------|
| Normal power cycle (sensor used regularly) | 30 seconds |
| Cold start / first use | 3 minutes |
| After heavy gas exposure | 5+ minutes to clear |
| After long storage | 10+ minutes first use |

The driver returns `d.ok = false` and `d.error = "warming up"` until warm-up completes. Don't skip this — readings during warm-up are random and will trigger false alarms.

## Load resistor — check your board

The AOUT voltage depends on the load resistor value (RL) in the voltage divider on your breakout board. Common values:

| Board | RL |
|-------|-----|
| SparkFun MICS-5524 | 10 kΩ |
| Most generic Chinese breakouts | 10 kΩ |
| Some boards | 4.7 kΩ or 22 kΩ |

Check the schematic or measure the resistor. Wrong RL = wrong Rs = wrong ppm. Call `setLoadResistance(your_RL_value)`.

## Humidity and temperature effects
Metal oxide sensors are sensitive to humidity:
- High humidity → reads lower than actual (humidity is slightly reducing)
- Temperature change → affects metal oxide response

The MICS-5524 datasheet gives correction curves. For most applications the error is 10–20% — acceptable for alarm/threshold use. For precise quantitative measurements, apply corrections using BME280 data.

## CO safety thresholds (for context)
| PPM | Effect |
|-----|--------|
| 1–70 | Normal indoor air (combustion appliances) |
| 70 | Headache, fatigue after prolonged exposure |
| 150 | Headache within 2–3 hours |
| 400 | Life-threatening within 3 hours |
| 800+ | Death within 2–3 hours |
| 3200+ | Death within 30 minutes |

**Note:** This sensor is NOT certified for life-safety CO detection. For actual CO alarms, use a certified CO detector with electrochemical sensor. This is for environmental monitoring and data logging.

## Gotchas

**Alcohol will trigger it.** Ethanol is one of the target gases. Hand sanitiser, cleaning products, and even fermentation smells near the sensor will cause readings. If you're using it for CO detection near a kitchen or bar, expect false positives.

**Silicone contamination permanently degrades it.** Silicone vapours (from RTV sealant, some conformal coatings, silicone cookware) poison metal oxide sensors irreversibly. Keep away from silicone products during operation and storage.

**Storage in a sealed bag with a desiccant** is recommended if not in use. Metal oxide sensors can drift if stored in fluctuating humidity for extended periods.

**The sensor is slow to clear after exposure.** If someone waves alcohol near it, it can take 5+ minutes to return to baseline. `d.voltage` (Rs in kΩ) tells you when it's back to baseline — should return close to R0.
