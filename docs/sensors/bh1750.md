# BH1750 — Ambient Light Sensor
**Driver:** `WyBH1750.h`

---

## What it does
Measures ambient light intensity in lux. This is what your phone uses to auto-adjust screen brightness. The BH1750 gives you a direct lux reading without any calibration — just read the number.

## Why it's useful
- Automatic backlight control on display projects
- Sunrise/sunset detection for outdoor lighting
- Grow light control (checking if supplemental light is needed)
- Logging light levels alongside temperature/humidity

## Wiring

| BH1750 Pin | ESP32 |
|-----------|-------|
| VCC | 3.3V |
| GND | GND |
| SDA | GPIO (any I2C SDA) |
| SCL | GPIO (any I2C SCL) |
| ADDR | GND for 0x23, 3.3V for 0x5C |

## I2C Addresses

| ADDR Pin | Address |
|---------|---------|
| GND or floating | `0x23` |
| 3.3V | `0x5C` |

## Specs

| Parameter | Value |
|-----------|-------|
| Measurement range | 1–65535 lux |
| Resolution | 1 lux (high-res mode), 0.5 lux (high-res 2), 4 lux (low-res) |
| Measurement time | 120ms (high-res), 16ms (low-res) |
| Interface | I2C, 400kHz |
| Supply voltage | 2.4–3.6V |

## Measurement Modes

| Mode constant | Resolution | Time | Use case |
|--------------|-----------|------|---------|
| `BH1750_MODE_CONT_HIGH` | 1 lux | 120ms | Default — continuous, good balance |
| `BH1750_MODE_CONT_HIGH2` | 0.5 lux | 120ms | Low-light environments |
| `BH1750_MODE_CONT_LOW` | 4 lux | 16ms | Fast updates, outdoor |
| `BH1750_MODE_ONE_HIGH` | 1 lux | 120ms | One-shot (sensor powers down after) |

## Code Example

```cpp
#include <WySensors.h>

WySensors sensors;
WyBH1750* lightSensor;

void setup() {
    lightSensor = sensors.addI2C<WyBH1750>("light", 21, 22, 0x23);
    sensors.begin();
}

void loop() {
    WySensorData d = sensors.read("light");
    if (d.ok) {
        Serial.printf("Light: %.1f lux\n", d.light);

        // Typical levels for reference:
        // <10 lux    — dim room
        // 100-300 lux — office lighting
        // 1000 lux   — overcast outdoor
        // 10000+ lux — bright sunlight
    }
    delay(500);
}
```

## Change mode at runtime

```cpp
// Switch to 0.5 lux resolution for a dimly lit sensor box
lightSensor->setMode(BH1750_MODE_CONT_HIGH2);
```

## WySensorData fields

| Field | Content |
|-------|---------|
| `light` | Illuminance in lux |
| `ok` | `true` if read succeeded |
| `error` | `"no data"` if I2C failed |

## Gotchas

**begin() does a test read.** If `begin()` returns `false`, the first measurement returned `0xFFFF` (all bits high), which means the sensor isn't connected or isn't responding. Check the address pin and wiring.

**Continuous mode reads stale data fast.** In continuous mode the sensor updates every 120ms (high-res). If you call `read()` faster than that, you get the same value repeatedly — not an error, just the last complete measurement.

**One-shot mode vs continuous.** One-shot modes trigger a fresh measurement on every `read()` call and add 120ms (or 24ms for low-res) of blocking delay. Continuous mode has no blocking delay on `read()` but adds a 180ms blocking delay in `begin()`. Choose based on your needs.

**0.5 lux resolution in HIGH2.** The conversion changes: `raw / 2.4` instead of `raw / 1.2`. The driver handles this automatically based on the mode.

**Sensor reads 0 in sunlight.** If placed in direct sunlight the sensor may saturate at 65535 lux and wrap. Most modules include a diffuser lens — don't remove it.

**Two BH1750s on one bus.** Put one at 0x23 and one at 0x5C for measuring two zones:
```cpp
sensors.addI2C<WyBH1750>("desk",   21, 22, 0x23);
sensors.addI2C<WyBH1750>("window", 21, 22, 0x5C);
```
